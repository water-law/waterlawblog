{"contents":[{"data":{"text":"Docker是一种在Linux容器里运行应用的开源工具，一种轻量级的虚拟机。除了运行应用，Docker还提供了一些工具，借助Docker Index或自己托管的Docker注册表对进行了集装箱化处理的应用进行分发，从而简化复杂应用的部署过程。","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031187},{"data":{"text":"我将在本文介绍如今在部署复杂系统时公司所面临的挑战，Docker怎样有效地解决这个问题，以及Docker的其他用例。","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031188},{"data":{"text":"部署的挑战","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":true,"t_indent":true}},"type":"headline","id":46031189},{"data":{"text":"服务器应用的部署已经越来越复杂了。把几个Perl脚本拷贝到正确目录就完成服务器应用的安装，这种时代已经一去不复返了。如今的软件有很多类型的需求：","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031190},{"data":{"text":"o 对已安装软件和库的依赖（“Python版本高于2.6.3，使用Django 1.2”）","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031191},{"data":{"text":"o 依赖于正在运行的服务（“需要一个MySQL 5.5数据库和一个RabbitMQ队列”）","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031192},{"data":{"text":"o 依赖于特定的操作系统（“在64位的Ubuntu Linux 12.04上构建、测试”）","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031193},{"data":{"text":"o 资源需求：","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031194},{"data":{"text":"最小的可用内存（“需要1GB的可用内存”）","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031195},{"data":{"text":"能绑定特定的端口（“绑定80和443端口”）","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031196},{"data":{"text":"我们来看一个相对简单的应用的部署：Wordpress。Wordpress的安装通常要求：","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031197},{"data":{"text":"o Apache 2","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031198},{"data":{"text":"o PHP 5","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031199},{"data":{"text":"o MySQL","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031200},{"data":{"text":"o Wordpress源码","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031201},{"data":{"text":"o 一个Wordpress MySQL数据库，配置Wordpress使用该数据库","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031202},{"data":{"text":"o Apache的配置：","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031203},{"data":{"text":"加载PHP模块","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031204},{"data":{"text":"支持URL重写和.htaccess文件","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031205},{"data":{"text":"指向WordPress源码的DocumentRoot","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031206},{"data":{"text":"在服务器上部署、运行这样一个系统，我们可能会遇到下面的问题和挑战：","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031207},{"data":{"text":"1. 隔离性：如果我们已经在这个服务器上部署了不同的网站，已有的网站只能在nginx上运行，而Wordpress依赖于Apache，这时我们就会有麻烦：它们都监听80端口。同时运行两个网站是可以的，但需要调整配置（修改监听端口），设置反向代理等。库级别也会出现类似的冲突，如果还要运行一个仍然依赖PHP4的老应用就会出问题，因为Wordpress不再支持PHP4，同时运行PHP4和PHP5则非常困难。运行在同一个服务器上的应用没有互相隔离（在文件系统级别和网络级别），所以它们可能会互相冲突。","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031208},{"data":{"text":"2. 安全性：Wordpress的安全记录并不是非常好。所以还是给它创建个沙箱，至少黑客入侵时不会影响其他运行的应用。","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031209},{"data":{"text":"3. 升级、降级：升级应用一般会覆盖现有文件。升级过程中会发生什么？系统要关闭么？如果升级失败，或者不对该怎么办？我们怎样快速回退到先前的版本？","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031210},{"data":{"text":"4. 快照、备份：一旦所有的内容都设置好，就给系统创建一个“快照”，以便能备份快照，甚至能移到另一个服务器上再次启动，或者拷贝到多个服务器上以备不时之需。","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031211},{"data":{"text":"5. 重复性：系统出新版本之后，比较好的做法是先在测试基础设施上自动部署并测试，然后再发布到生产系统。通常会利用诸如Chef、Puppet等工具在服务器上自动安装一堆包，等一切内容都就绪后，再在生产系统上运行相同的部署脚本。这在百分之九十九的情况下都没有问题。但有百分之一的例外，在部署到测试环境和生产环境之间的时间跨度里，你依赖的包在包仓库里有了更新，而新版本并不兼容。结果生产环境的设置和测试环境不同，还有可能破坏生产系统。假如没有控制部署的每一个方面（例如托管自己的APT或YUM仓库），持续在多个阶段（比如测试、预演、生产环境）重复搭建出完全相同的系统就很困难。","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031212},{"data":{"text":"6. 资源限制：如果我们的Wordpress耗费CPU资源，并占用了所有的CPU周期，导致其他应用无法做任何事情怎么办？如果它用尽了全部可用的内存呢？或者疯狂写日志阻塞磁盘呢？要是能限制应用的可用资源，比如CPU、内存和磁盘空间，就会非常方便。","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031213},{"data":{"text":"7. 易于安装：也许有Debian或CentOS包，抑或是能自动执行所有复杂步骤并安装Wordpress的Chef菜谱。但这些菜谱很难稳定下来，因为它们需要考虑目标系统上可能的系统配置。很多情况下，这些菜谱只能在干净的系统上运行。因此，你不太可能更换成自己的包或Chef菜谱。这样的话，安装就是个复杂的系统工程，而不是午休期间就能搞定的事情。","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031214},{"data":{"text":"8. 易于移除：软件应该能轻松、干净地移除，不留痕迹。但部署应用通常要调整已有的配置文件、设置状态（MySQL数据库的数据，日志），完全移除应用也变得不那么容易。","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031215},{"data":{"text":"那我们应该如何解决这些问题呢？","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031216},{"data":{"text":"虚拟机！","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":true,"t_indent":true}},"type":"headline","id":46031217},{"data":{"text":"我们决定在单独的虚拟机上运行独立的应用，例如Amazon的EC2，大部分问题这时会迎刃而解：","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031218},{"data":{"text":"1.隔离性：在一个VM上安装一个应用，应用是完全独立的，除非它们攻入了对方的防火墙。","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031219},{"data":{"text":"2.重复性：用你喜欢的方式准备系统，然后创建一个AMI。你可以随意实例化多个AMI实例。完全是可重现的。","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031220},{"data":{"text":"3.安全性：由于我们完全隔离，如果Wordpress遭到攻击，其余的基础设施并不会受到影响——除非你没有保管好SSH密钥或者在哪里都使用同一个密码，但你应该不会这么做吧？","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031221},{"data":{"text":"4.资源限制：VM会分配特定的CPU周期、可用内存和磁盘空间，没有加价的话就不能超额。","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031222},{"data":{"text":"5.易于安装：越来越多的应用能够在EC2上运行，只要在AWS marketplace上点击一个按钮就能实例化应用。启动只需要几分钟，就是这样。","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031223},{"data":{"text":"6.易于移除：不需要某个应用了？销毁VM。干净又方便。","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031224},{"data":{"text":"7.升级、降级：Netflix如何部署代码里提到，只需要在新VM上部署新版本，然后让负载均衡器指向部署了新版本的VM。不过应用如果需要在本地保存状态，这种方法就不是很好用了。","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031225},{"data":{"text":"8.快照、备份：点击一个按钮（或者调用一下API）就能获得EBS磁盘的快照，快照会备份到S3中。","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031226},{"data":{"text":"完美！","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":true,"t_indent":true}},"type":"headline","id":46031227},{"data":{"text":"不过……我们有个新问题：虚拟机在两个方面比较昂贵：","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031228},{"data":{"text":"o 金钱：你真的有那么多钱为每个应用启动一个EC2实例？另外你能预测到需要多少个实例么？如果你以后需要更多的资源，你需要停止VM进行升级——否则就要为闲置资源白白付钱，直到真正用起来（除非你用能动态调整大小的Solaris Zones，比如Joyent上的）。","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031229},{"data":{"text":"o 时间：虚拟机相关的操作大多都很慢：启动要几分钟，捕捉快照要几分钟，创建镜像也需要几分钟。世界不停转动，我们可没有这种时间！","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031230},{"data":{"text":"我们能做得更好吗？","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031231},{"data":{"text":"进入Docker的世界吧。","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031232},{"data":{"text":"Docker是由公共PaaS提供商dotCloud的人发起的开源项目，于去年初发起。从技术角度来说，Docker（主要用Go语言编写）试图简化两种已有技术的使用：","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031233},{"data":{"text":"o LXC：Linux容器，允许独立进程在比普通Unix进程更高的隔离级别上运行。使用的技术术语是集装箱化：一个容器里运行一个进程。容器支持的隔离级别有：","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031234},{"data":{"text":"文件系统：容器只能访问自己的沙箱文件系统（类似于chroot），否则要专门挂载到容器的文件系统中才能访问。","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031235},{"data":{"text":"用户名字空间：容器有自己的用户数据库（也就是容器的root不等于主机的root账户）。","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031236},{"data":{"text":"进程名字空间：只有容器里的进程才是可见的（ps aux的输出会非常简洁）。","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031237},{"data":{"text":"网络名字空间：每个容器都有自己的虚拟网络设备和虚拟IP（因此它可以绑定任意端口，不用占用主机端口）。","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031238},{"data":{"text":"o AUFS：高级多层的统一文件系统，可用来创建联合、写时拷贝的文件系统。","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031239},{"data":{"text":"Docker可以安装在任何支持AUFS和内核版本大于等于3.8的Linux系统上。但从概念上来说它并不依赖于这些技术，以后也可以和类似的技术一起运行，例如Solaris的Zones或BSD jails，并将ZFS作为文件系统。不过目前只能选择Linux 3.8+和AUFS。","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031240},{"data":{"text":"那Docker为什么有意思呢？","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031241},{"data":{"text":"o Docker非常轻量。启动VM是个大动作，需要占用大量内存；而启动Docker容器只耗费很少的CPU和内存，并且非常快。几乎和启动一个常规进程没什么区别。不仅运行容器快，构建镜像、捕获文件系统的快照也很快。","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031242},{"data":{"text":"o 它运行在已经虚拟化过的环境中。也就是说，你可以在EC2实例、Rackspace VM或VirtualBox里运行Docker。事实上，在Mac和Windows上使用Docker的首选方式是使用Vagrant。","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031243},{"data":{"text":"o Docker容器能移植到任何运行Docker的操作系统上。无论是Ubuntu还是CentOS，只要Docker运行着，你的容器就能运行。","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031244},{"data":{"text":"让我们回到前面的部署、操作问题列表，看看Docker是怎么解决的：","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031245},{"data":{"text":"1.隔离性：Docker在文件系统和网络级别隔离了应用。从这个意义上来讲很像在运行”真正的“虚拟机。","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031246},{"data":{"text":"2.重复性：用你喜欢的方式准备系统（登录并在所有软件里执行apt-get命令，或者使用Dockerfile），然后把修改提交到镜像中。你可以随意实例化若干个实例，或者把镜像传输到另一台机器，完全重现同样的设置。","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031247},{"data":{"text":"安全性：Docker容器比普通的进程隔离更为安全。Docker团队已经确定了一些安全问题，正在着手解决。","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031248},{"data":{"text":"资源约束：Docker现在能限制CPU的使用率和内存用量。目前还不能直接限制磁盘的使用情况。","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031249},{"data":{"text":"易于安装：Docker有一个Docker Index，这个仓库存储了现成的Docker镜像，你用一条命令就可以完成实例化。比如说，要使用Clojure REPL镜像，只要运行docker run -t -i zefhemel\/clojure-repl命令就能自动获取并运行该镜像。","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031250},{"data":{"text":"易于移除：不需要应用了？销毁容器就行。","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031251},{"data":{"text":"升级、降级：和EC2 VM一样：先启动应用的新版本，然后把负载均衡器切换到新的端口。","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031252},{"data":{"text":"快照、备份：Docker能提交镜像并给镜像打标签，和EC2上的快照不同，Docker是立即处理的。","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031253},{"data":{"text":"怎么使用Docker","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":true,"t_indent":true}},"type":"headline","id":46031254},{"data":{"text":"假设你已经安装了Docker。要在Ubuntu容器中运行bash，只要执行：","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031255},{"data":{"text":"docker run -t -i ubuntu \/bin\/bash","language":"bash","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"code","id":46044285},{"data":{"text":"根据“ubuntu”镜像的下载情况，Docker会选择下载或者使用本地可用的拷贝，然后在Ubuntu容器里运行\/bin\/bash。接着你就能在容器里执行几乎所有典型的Ubuntu操作，比如安装新的包。","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031256},{"data":{"text":"我们来安装个“hello”：","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031257},{"data":{"text":"\n$ docker run -t -i ubuntu \/bin\/bash\nroot@78b96377e546:\/# apt-get install hello\nReading package lists... Done\nBuilding dependency tree... Done\n\nThe following NEW packages will be installed:\n  hello\n0 upgraded, 1 newly installed, 0 to remove and 0 not upgraded.\n\nNeed to get 26.1 kB of archives.\nAfter this operation, 102 kB of additional disk space will be used.\nGet:1 http:\/\/archive.ubuntu.com\/ubuntu\/ precise\/main hello amd64 2.7-2 [26.1 kB]\nFetched 26.1 kB in 0s (390 kB\/s)\ndebconf: delaying package configuration, since apt-utils is not installed\nSelecting previously unselected package hello.\n(Reading database ... 7545 files and directories currently installed.)\nUnpacking hello (from ...\/archives\/hello_2.7-2_amd64.deb) ...\nSetting up hello (2.7-2) ...\nroot@78b96377e546:\/# hello\nHello, world!","language":"bash","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"code","id":46044286},{"data":{"text":"现在退出，然后再运行一次相同的Docker命令：","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031258},{"data":{"text":"root@78b96377e546:\/# exit\nexit\n$ docker run -t -i ubuntu \/bin\/bash\nroot@e5e9cde16021:\/# hello\nbash: hello: command not found","language":"","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"code","id":46044287},{"data":{"text":"怎么了？我们美丽的hello命令哪儿去了？事实上我们刚刚根据干净的Ubuntu镜像启动了一个新的容器。要继续先前那个，我们必须把它提交到仓库中。我们退出这个容器，看看先前启动容器的ID是什么：","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031259},{"data":{"text":"$ docker ps -a\nID                  IMAGE                   COMMAND                CREATED              STATUS              PORTS\ne5e9cde16021        ubuntu:12.04            \/bin\/bash              About a minute ago   Exit 127\n78b96377e546        ubuntu:12.04            \/bin\/bash              2 minutes ago        Exit 0","language":"bash","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"code","id":46044288},{"data":{"text":"docker ps命令能列出当前运行的容器，docker ps -a还会显示已经退出的容器。每个容器都有一个唯一的ID，类似于Git提交哈希值。命令也列出了容器基于的镜像、运行的命令、创建时间、当前状态，以及容器暴露的端口和与主机端口之间的映射。","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031260},{"data":{"text":"上面那个是我们第二次启动的容器，不包含“hello”；下面那个是我们想重用的，所以我们提交一下，再创建一个新的容器：","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031261},{"data":{"text":"$ docker commit 78b96377e546 zefhemel\/ubuntu\n356e4d516681\n\n$ docker run -t -i zefhemel\/ubuntu \/bin\/bash\nroot@0d7898bbf8cd:\/# hello\nHello, world!","language":"bash","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"code","id":46044289},{"data":{"text":"我用容器ID把容器提交到了仓库中。仓库类似于Git仓库，包含一或多个打了标签的镜像。如果像我一样没有指定标签名称，标签会被命名为“latest”。运行docker images命令可以查看本地安装的所有镜像。","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031262},{"data":{"text":"Docker提供了一些基础镜像（比如ubuntu和centos），你也可以创建自己的镜像。用户仓库的命名模型和Github的类似：Docker用户名后面跟一个斜线，然后再跟仓库名称。","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031263},{"data":{"text":"前面创建Docker镜像的方式并不是特别正规，你可以试试。更简洁的方式是使用Dockerfile。","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031264},{"data":{"text":"使用Dockerfile构建镜像","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":true,"t_indent":true}},"type":"headline","id":46031265},{"data":{"text":"Dockerfile是个简单的文本文件，介绍了如何从基础镜像构建镜像。我在Github上提供了几个Dockerfile。下面的文件用来运行、安装SSH服务器：","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031266},{"data":{"text":"FROM ubuntu\nRUN apt-get update\nRUN apt-get install -y openssh-server\nRUN mkdir \/var\/run\/sshd\nRUN echo \"root:root\" | chpasswd\nEXPOSE 22","language":"bash","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"code","id":46044290},{"data":{"text":"上面的内容一目了然。FROM命令定义了基础镜像，基础镜像可以是官方的，也可以是我们刚刚创建的zefhemel\/ubuntu。RUN命令用来配置镜像。在这里，我们更新了APT包仓库，安装了openssh-server，创建了一个目录，然后给我们的root账户设置了一个再简单不过的密码。EXPOSE命令会向外暴露22端口（SSH端口）。接下来看看如何构建并实例化这个Dockerfile。","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031267},{"data":{"text":"第一步是构建一个镜像。在包含Dockerfile的目录下运行：","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031268},{"data":{"text":"$ docker bui ld -t zefhemel\/ssh .","language":"bash","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"code","id":46044291},{"data":{"text":"这会创建一个zefhemel\/ssh仓库，包含我们新的SSH镜像。如果创建成功，就能进行实例化了：","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031269},{"data":{"text":"\n$ docker run -d zefhemel\/ssh \/usr\/sbin\/sshd -D","language":"bash","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"code","id":46044292},{"data":{"text":"和前面的命令不一样。-d表示会在后台运行容器，而不是运行bash，所以我们用前台模式（用-D参数指定）运行了sshd守护进程。","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031270},{"data":{"text":"让我们检查运行中的容器，看看命令做了些什么：","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031271},{"data":{"text":"$ docker ps\nID                  IMAGE                   COMMAND                CREATED             STATUS              PORTS\n23ee5acf5c91        zefhemel\/ssh:latest     \/usr\/sbin\/sshd -D      3 seconds ago       Up 2 seconds        49154->22\n","language":"bash","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"code","id":46044293},{"data":{"text":"可以看到我们的容器启动着。PORTS头下的内容比较有意思。由于我们EXPOSE了22端口，这个端口现在映射到了主机系统的一个端口（这里是49154）。让我们看看它能否运行。","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031272},{"data":{"text":"$ ssh root@localhost -p 49154\nThe authenticity of host '[localhost]:49154 ([127.0.0.1]:49154)' can't be established.\nECDSA key fingerprint is f3:cc:c1:0b:e9:e4:49:f2:98:9a:af:3b:30:59:77:35.\nAre you sure you want to continue connecting (yes\/no)? yes\nWarning: Permanently added '[localhost]:49154' (ECDSA) to the list of known hosts.\nroot@localhost's password: <I typed in 'root' here>\nWelcome to Ubuntu 12.04 LTS (GNU\/Linux 3.8.0-27-generic x86_64)\n\n * Documentation:  https:\/\/help.ubuntu.com\/\n\nThe programs included with the Ubuntu system are free software;\nthe exact distribution terms for each program are described in the\nindividual files in \/usr\/share\/doc\/*\/copyright.\n\nUbuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by\napplicable law.\n\n\nroot@23ee5acf5c91:~#","language":"bash","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"code","id":46044294},{"data":{"text":"再次成功了！现在有了一个运行的SSH服务器，我们能登录它。在有人猜出密码并攻击容器之前，让我们先从SSH退出，杀掉容器。","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031273},{"data":{"text":"$ docker kill 23ee5acf5c91","language":"bash","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"code","id":46044295},{"data":{"text":"如你所见，容器的22端口映射到了49154端口，但这是完全随机的。要把它映射到特定端口，运行命令时传入-p参数：","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031274},{"data":{"text":"docker run -p 2222:22 -d zefhemel\/ssh \/usr\/sbin\/sshd -D","language":"bash","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"code","id":46044296},{"data":{"text":"现在，如果2222端口可用，我们的端口就会映射到2222上。我们在Dockerfile的结尾再添加一行内容，以便我们的镜像对用户更加友好：","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031275},{"data":{"text":"CMD \/usr\/sbin\/sshd -D","language":"bash","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"code","id":46044297},{"data":{"text":"CMD表示构建镜像时并不会运行命令，实例化时才运行。所以不传递其它参数时就会执行\/usr\/sbin\/sshd -D。然后我们可以直接运行：","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031276},{"data":{"text":"docker run -p 2222:22 -d zefhemel\/ssh","language":"bash","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"code","id":46044298},{"data":{"text":"得到的结果和前面一样。要发布新创建的镜像，只要运行docker push就可以了：","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031277},{"data":{"text":"docker push zefhemel\/ssh","language":"bash","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"code","id":46044299},{"data":{"text":"登录之后，镜像就可用了，用先前的docker run命令就能执行命令。","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031278},{"data":{"text":"让我们回到Wordpress的例子。怎样在容器里用Docker运行Wordpress呢？要构建一个Wordpress镜像，我们要创建一个Dockerfile：","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031279},{"data":{"text":"1. 安装Apache、PHP5和MySQL","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031280},{"data":{"text":"2. 下载Wordpress，解压到文件系统的某个地方","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031281},{"data":{"text":"3. 创建一个MySQL数据库","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031282},{"data":{"text":"4. 更新WordPress的配置文件，指向MySQL数据库","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031283},{"data":{"text":"5. 把WordPress设置为Apache的DocumentRoot","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031284},{"data":{"text":"6. 启动MySQL和Apache（比如用supervisord）","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031285},{"data":{"text":"幸运的是，很多人已经成功了，比如John Fink的GitHub库就包括创建这样一个Wordpress镜像需要的所有内容。","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031286},{"data":{"text":"Docker用例","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":true,"t_indent":true}},"type":"headline","id":46031287},{"data":{"text":"除了用可靠、可重复的方式简化复杂应用的部署，Docker还有很多用途。下面是一些有趣的Docker用法和项目：","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031288},{"data":{"text":"o 持续集成和部署：在Docker容器里构建软件，确保构建之间的隔离性。构建好的软件镜像可以自动推到私有的Docker仓库中，并部署到测试环境或生产环境。","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031289},{"data":{"text":"o Dokku：一个简单的PaaS，用不到一百行的Bash构建而成。","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031290},{"data":{"text":"o Flynn和Deis，两个使用Docker的开源PaaS项目。","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031291},{"data":{"text":"o 在容器里运行桌面环境。","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031292},{"data":{"text":"o CoreOS验证了Docker的合理性，CoreOS是个非常轻量级的Linux发行版，其中的应用都用Docker安装、运行，由systemd管理。","format":{"p_indent":true,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031293},{"data":{"text":"Docker不是什么","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":true,"t_indent":true}},"type":"headline","id":46031294},{"data":{"text":"尽管Docker有助于系统的可靠部署，但它本身并不是个完全成熟的部署系统。它操作的是容器里运行的应用。哪个容器安装在哪个服务器上，以及如何启动它们，则超出了Docker的范围。","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031295},{"data":{"text":"同样的，Docker也不处理跨多个容器（可能在多个物理服务器上，也可能在多个VM上）运行的应用。要让容器互相通信，需要某些发现机制，来找出哪些IP和端口上的其他应用可用。这和跨常规虚拟机的服务发现非常相似。etcd等工具，或者其他的服务发现机制都能用来解决这个问题。","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031296},{"data":{"text":"结论","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":true,"t_indent":true}},"type":"headline","id":46031297},{"data":{"text":"虽然本文描述的所有内容用原始的LXC、cgroups和AUFS也可能实现，但实现起来绝对没有那么容易或简单。Docker提供了一种简单的方式将复杂应用打包到容器中，而且能轻松版本化、可靠分发。进而让轻量级的Linux容器和真正的虚拟机一样灵活、强大，但成本更低、方式更为便捷。即便Vagrant VirtualBox VM在Macbook Pro上，使用运行在其中的Docker创建的Docker镜像也能很好地运行在EC2、Rackspace Cloud或物理硬件上，反之亦然。","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031298},{"data":{"text":"Docker可以从它的网站上获取，并免费使用。交互式的入门指南很不错。项目的路线图指出，第一个生产就绪的版本是2013年10月发布的0.8版本，不过此前大家已经在生产环境里使用Docker了。","format":{"p_indent":false,"p_center":false,"p_quote":false,"p_align":"left","p_bold":false,"t_indent":false}},"type":"paragraph","id":46031299}],"title":"推荐文章 ： Docker：利用Linux容器实现可移植的应用部署"}